# -*- coding: utf-8 -*-
import seaborn as sns
from matplotlib import pyplot as plt
import os
import re

from qa4sm_reader import globals
from qa4sm_reader.dfplot import _get_globmeta, get_value_range, make_watermark, init_plot, get_plot_extent, \
    geotraj_to_geo2d, _make_cbar, _make_title, style_map

from qa4sm_reader.meta_img import QA4SM_MetaImg


def boxplot(df, varmeta, title=None, label=None, print_stat=globals.boxplot_printnumbers,
            watermark_pos=globals.watermark_pos, figsize=None,
            dpi=globals.dpi, add_title=True, title_pad=globals.title_pad):
    """
    Create a boxplot from the variables in df.
    The box shows the quartiles of the dataset while the whiskers extend
    to show the rest of the distribution, except for points that are
    determined to be “outliers” using a method that is a function of
    the inter-quartile range.

    Parameters
    ----------
    df : pandas.DataFrame
        DataFrame containing 'lat', 'lon' and (multiple) 'var' Series.
    varmeta : dict
        dictionary of metadata for each var. See interface.get_varmeta().
    title : str, optional
        Title of the plot. If None, a title is autogenerated from metadata.
        The default is None.
    label : str, optional
        Label of the y axis, describing the metric. If None, a label is autogenerated from metadata.
        The default is None.
    print_stat : bool, optional
        Wheter to print median, standard derivation and n_obs .
        The default is globals.boxplot_printnumbers.
    watermark_pos : str, optional
        Placement of watermark. 'top' | 'bottom' | None.
        If None, no watermark gets placed.
        The default is globals.watermark_pos.
    figsize : tuple, optional
        Figure size in inches. The default is globals.map_figsize.
    dpi : int, optional
        Resolution for raster graphic output. The default is globals.dpi.
    add_title : bool, optional
        The default is True.
    title_pad : float, optional
        pad the title by title_pad pt. The default is globals.title_pad.

    Returns
    -------
    fig : TYPE
        DESCRIPTION.
    ax : TYPE
        DESCRIPTION.

    """
    # === select only relevant variables, creating a view of the passed DataFrame.
    # This preserves also renaming the columns of the original DataFrame.
    df = df[varmeta]

    # === rename columns = label of boxes ===
    if print_stat:
        df.columns = ['{0}\n({1})\nmedian: {2:.3g}\nstd. dev.: {3:.3g}\nN obs.: {4:d}'.format(
            varmeta[var]['ds_pretty_name'],
            varmeta[var]['ds_version_pretty_name'],
            df[var].median(),
            df[var].std(),
            df[var].count()) for var in varmeta]
    else:
        df.columns = ['{}\n{}'.format(
            varmeta[var]['ds_pretty_name'],
            varmeta[var]['ds_version_pretty_name']) for var in varmeta]

    # === plot ===
    if not figsize:
        # figsize = globals.boxplot_figsize
        figsize = [globals.boxplot_width*(1+len(df.columns)), globals.boxplot_height]
    fig, ax = plt.subplots(figsize=figsize, dpi=dpi)
    sns.set_style("whitegrid")  # TODO: Bug. does not work for the first plot (test_boxplot_ISMN_default()) for some strange reason!!!
    ax = sns.boxplot(data=df, ax=ax, width=0.15, showfliers=False, color='white')
    sns.despine()  # remove ugly spines (=border around plot) right and top.

    # === style ===
    globmeta = _get_globmeta(varmeta)
    metric = globmeta['metric']
    ax.set_ylim(get_value_range(df, metric))
    if not label:
        label = (globals._metric_name[metric] +
                 globals._metric_description[metric].format(globals._metric_units[globmeta['ref']]))
    ax.set_ylabel(label, weight='normal')  # TODO: Bug: If a circumflex ('^') is in the string, it becomes bold.)

    # === generate title with automatic line break ===
    if add_title:
        if not title:
            max_title_len = globals.boxplot_title_len * len(df.columns)
            if globmeta['metric'] == 'n_obs':  # special case n_obs.
                title = list()  # each list element is a line in the plot title
                title.append(
                    'Number of spacial and temporal matches between {} ({})'.format(
                        globmeta['ref_pretty_name'], globmeta['ref_version_pretty_name']))
                for name in varmeta['n_obs']['ds_pretty_name']:  # TODO: have a look at parawrap (https://www.tutorialspoint.com/python/python_text_wrapping) or textwrap (https://www.geeksforgeeks.org/textwrap-text-wrapping-filling-python/)
                    to_append = '{}, '.format(name)
                    if len(title[-1] + to_append) <= max_title_len:  # line not to long: add to current line
                        title[-1] += to_append
                    else:  # add to next line
                        title.append(to_append)
            else:
                title = list()  # each list element is a line in the plot title
                title.append(
                    'Comparing {} ({}) to '.format(globmeta['ref_pretty_name'], globmeta['ref_version_pretty_name']))
                for var in varmeta:
                    to_append = '{}, '.format(varmeta[var]['ds_pretty_name'])
                    if len(title[-1] + to_append) <= max_title_len:  # line not to long: add to current line
                        title[-1] += to_append
                    else:  # add to next line
                        title.append(to_append)
            title = '\n'.join(title)[:-2]  # join lines together and remove last ', '
            title = ' and '.join(title.rsplit(', ', 1))  # replace last ', ' with ' and '
        ax.set_title(title, pad=title_pad)

    # === watermark ===
    plt.tight_layout()
    if watermark_pos:
        make_watermark(fig, watermark_pos)
    return fig, ax


def mapplot(df, var, meta, title=None, label=None, plot_extent=None,
            colormap=None, figsize=globals.map_figsize, dpi=globals.dpi,
            projection=None, watermark_pos=globals.watermark_pos,
            add_title=True, add_cbar=True,
            **style_kwargs):
    """
    Create an overview map from df using df[var] as color.
    Plots a scatterplot for ISMN and a image plot for other input data.

    Parameters
    ----------
    df : pandas.DataFrame
        DataFrame containing 'lat', 'lon' and 'var' Series.
    var : str
        variable to be plotted.
    meta : dict
        dictionary of metadata. See interface.get_meta().
    title : str, optional
        Title of the plot. If None, a title is autogenerated from metadata.
        The default is None.
    label : str, optional
        Label of the colorbar. If None, a label is autogenerated from metadata.
        The default is None.
    plot_extent : tuple
        (x_min, x_max, y_min, y_max) in Data coordinates. The default is None.
    colormap : str, optional
        colormap to be used.
        If None, defaults to globals._colormaps.
        The default is None.
    figsize : tuple, optional
        Figure size in inches. The default is globals.map_figsize.
    dpi : int, optional
        Resolution for raster graphic output. The default is globals.dpi.
    projection : cartopy.crs, optional
        Projection to be used. If none, defaults to globals.map_projection.
        The default is None.
    watermark_pos : str, optional
        Placement of watermark. 'top' | 'bottom' | None.
        If None, no watermark gets placed.
        The default is globals.watermark_pos.
    add_title : bool, optional
        The default is True.
    add_cbar : bool, optional
        Add a colorbar. The default is True.
    **style_kwargs :
        Keyword arguments for plotter.style_map().

    Returns
    -------
    fig : matplotlib.figure

    ax : matplotlib.axes
        axes containing the plot without colorbar, watermark etc.
    """
    # === value range ===
    if isinstance(meta['metric'], list):
        meta['metric'] = meta['metric'][0]
    v_min, v_max = get_value_range(df[var], metric)

    # === init plot ===
    fig, ax, cax = init_plot(figsize, dpi, add_cbar, projection)

    if not colormap:
        #colormap = globals._colormaps[meta['metric']]
        cmap = globals._colormaps[meta['metric']]
    #cmap = plt.cm.get_cmap(colormap)

    # === scatter or mapplot ===
    if meta['ref'] in globals.scattered_datasets:  # === scatterplot ===
        # === coordiniate range ===
        if not plot_extent:
            plot_extent = get_plot_extent(df)

        # === marker size ===
        markersize = globals.markersize ** 2  # in points**2

        # === plot ===
        lat, lon = globals.index_names
        im = ax.scatter(df[lon], df[lat], c=df[var],
                        cmap=cmap, s=markersize, vmin=v_min, vmax=v_max, edgecolors='black',
                        linewidths=0.1, zorder=2, transform=globals.data_crs)
    else:  # === mapplot ===
        # === coordiniate range ===
        if not plot_extent:
            plot_extent = get_plot_extent(df, grid=True)

        # === prepare data ===
        zz, zz_extent = geotraj_to_geo2d(df, var)

        # === plot ===
        im = ax.imshow(zz, cmap=cmap, vmin=v_min, vmax=v_max,
                       interpolation='nearest', origin='lower',
                       extent=zz_extent,
                       transform=globals.data_crs, zorder=2)

    # === add colorbar ===
    if add_cbar:
        _make_cbar(fig, im, cax, df[var], v_min, v_max, meta, label)

    # === style ===
    if add_title:
        _make_title(ax, meta, title)
    style_map(ax, plot_extent, **style_kwargs)

    # === layout ===
    fig.canvas.draw()  # very slow. necessary bcs of a bug in cartopy: https://github.com/SciTools/cartopy/issues/1207
    plt.tight_layout()  # pad=1)  # pad=0.5,h_pad=1,w_pad=1,rect=(0, 0, 1, 1))

    # === watermark ===
    if watermark_pos:
        make_watermark(fig, watermark_pos)

    return fig, ax

class QA4SM_MetaImg_Plotter(QA4SM_MetaImg):
    def __init__(self, filepath):
        super(QA4SM_MetaImg_Plotter, self).__init__(filepath)

    @staticmethod
    def _get_dir_name_type(out_dir, out_name, out_type):
        """
        Standardized behaviour for filenames.

        Parameters
        ----------
        out_dir : [ str | None ]
            path to the output directory.
            if None, uses the current working directory.
        out_name : str
            output filename.
            if it contains an extension (e.g. 'MyName.png'), the extension is added to out_ext.
        out_type : [ str | iterable | None ]
            contains file extensions to be plotted.
            if None, '.png' is used. If '.' is missing, it is added.

        Returns
        -------
        out_dir : str
        out_name : str
        out_ext : set
            file extensions

        """
        # directory
        if not out_dir:
            out_dir = ''
        out_dir = os.path.abspath(out_dir)
        # file name
        (out_name, ext) = os.path.splitext(out_name)  # remove extension
        # file type
        if not out_type:
            if ext:
                out_type = ext
            else:
                out_type = '.png'
        # convert to a set
        if isinstance(out_type, str):
            out_type = {out_type}
        else:  # some iterable
            out_type = set(out_type)
        if ext:
            out_type.add(ext)
        out_type = {ext if ext[0] == "." else "." + ext for ext in out_type}  # make sure all entries start with a '.'
        return out_dir, out_name, out_type

    def boxplot(self, metric, extent=None, out_dir=None, out_name=None, out_type=None,
                **plot_kwargs):
        """
        Creates a boxplot, displaying the variables corresponding to given metric.
        Saves a figure and returns Matplotlib fig and ax objects for further processing.

        Parameters
        ----------
        filepath : str
            Path to the *.nc file to be processed.
        metric : str
            metric that is collected from the file for all datasets and combined
            into one plot.
        extent : list
            [x_min,x_max,y_min,y_max] to create a subset of the data
        out_dir : [ None | str ], optional
            Path to output generated plot.
            If None, defaults to the current working directory.
            The default is None.
        out_name : [ None | str ], optional
            Name of output file.
            If None, defaults to a name that is generated based on the variables.
            The default is None.
        out_type : [ str | list | None ], optional
            The file type, e.g. 'png', 'pdf', 'svg', 'tiff'...
            If list, a plot is saved for each type.
            If None, no file is saved.
            The default is png.
        **plot_kwargs : dict, optional
            Additional keyword arguments that are passed to dfplot.boxplot.

        Returns
        -------
        fig : matplotlib.figure.Figure
            Figure containing the axes for further processing.
        ax : matplotlib.axes.Axes or list of Axes objects
            Axes or list of axes containing the plot.
        """
        fnames = list()  # list to store all filenames.
        # === load data and metadata ===
        df, varmeta = self.load_metric_and_meta(metric, extent)

        # === plot data ===
        fig, ax = boxplot(df=df, varmeta=varmeta, **plot_kwargs)

        # === save ===
        if not out_name:
            out_name = 'boxplot_{}'.format(metric)

        if out_dir is None:
            return fig, ax
        else:
            out_dir, out_name, out_type = self._get_dir_name_type(
                out_dir, out_name, out_type)
            if not os.path.exists(out_dir):
                os.makedirs(out_dir)
            for ending in out_type:
                fname = os.path.join(out_dir, out_name+ending)
                plt.savefig(fname, dpi='figure')
                fnames.append(fname)
            plt.close()
            return fnames


    def mapplot(self, var, extent=None, out_dir=None, out_name=None, out_type=None,
                **plot_kwargs):
        """
        Plots data to a map, using the data as color. Plots a scatterplot for
        ISMN and a image plot for other input data.

        Parameters
        ----------
        filepath : str
            Path to the *.nc file to be processed.
        var : str
            variable to be plotted.
        extent : list
            [x_min,x_max,y_min,y_max] to create a subset of the data
        out_dir : [ None | str ], optional
            Path to output generated plot.
            If None, defaults to the current working directory.
            The default is None.
        out_name : [ None | str ], optional
            Name of output file.
            If None, defaults to a name that is generated based on the variables.
            The default is None.
        out_type : [ str | list | None ], optional
            The file type, e.g. 'png', 'pdf', 'svg', 'tiff'...
            If list, a plot is saved for each type.
            If None, no file is saved.
            The default is png.
        **plot_kwargs : dict, optional
            Additional keyword arguments that are passed to dfplot.

        Returns
        -------
        fig : matplotlib.figure.Figure
            Figure containing the axes for further processing.
        ax : matplotlib.axes.Axes or list of Axes objects
            Axes or list of axes containing the plot.

        """
        fnames = list()  # list to store all filenames.

        # if isinstance(var, str):
        #     var = [var]  # raise IOError('var needs to be a string, not {}.'.format(type(var)))

        # === Get ready... ===
        #df = self._ds2df([var], extent)
        df = self._ds2df([var], extent)
        varmeta = self.get_var_meta([var])
        meta = varmeta[var]
        # === plot data ===
        fig, ax = mapplot(df=df, var=var, plot_extent=extent, meta=meta, **plot_kwargs)

        # === save ===
        if not out_name:
            ds_match = re.match(r'.*_between_(([0-9]+)-(.*)_([0-9]+)-(.*))', var)
            if ds_match:
                pair_name = ds_match.group(1)
            else:
                pair_name = var  # e.g. n_obs

            if meta['metric'] == pair_name:  # e.g. n_obs
                out_name = 'overview_{}'.format(meta['metric'])
            else:
                out_name = 'overview_{}_{}'.format(pair_name, meta['metric'])

        if out_dir is None:
            return fig, ax
        else:
            out_dir, out_name, out_type = self._get_dir_name_type(out_dir, out_name, out_type)
            if not os.path.exists(out_dir):
                os.makedirs(out_dir)
            for ending in out_type:
                fname = os.path.join(out_dir, out_name+ending)
                plt.savefig(fname, dpi='figure')
                fnames.append(fname)
            plt.close()
        return fnames

if __name__ == '__main__':
    tcfile= r"H:\code\qa4sm-reader\tests\test_data\3-ERA5_LAND.swvl1_with_1-C3S.sm_with_2-SMOS.Soil_Moisture.nc"
    plotter = QA4SM_MetaImg_Plotter(tcfile)
    out_dir = r"C:\Temp\qa4smreader_plots"
    metrics = plotter.metrics_in_file(group=False)
    for metric in metrics:
        print(metric)
        #plotter.boxplot(metric, out_dir=out_dir)
        vars = plotter._met2vars(metric)
        for var in vars:
            plotter.mapplot(var, out_dir=out_dir)
    #plotter.boxplot('n_obs', out_dir=out_dir)


