# -*- coding: utf-8 -*-
import seaborn as sns
import os
from qa4sm_reader.plot_utils import *
from qa4sm_reader.meta_img import QA4SM_MetaImg

def _make_cbar(fig, im, cax, meta):
    metric = meta['metric']
    ref = meta['ref']
    try:
        label = globals._metric_name[metric] + \
                globals._metric_description[metric].format(
                    globals._metric_units[ref])
    except KeyError as e:
        raise Exception('The metric \'{}\' or reference \'{}\' is not known.\n'.format(metric, ref) + str(e))
    extend = get_extend_cbar(metric)
    cbar = fig.colorbar(im, cax=cax, orientation='horizontal', extend=extend)
    cbar.set_label(label, weight='normal')  # TODO: Bug: If a circumflex ('^') is in the string, it becomes bold.)
    cbar.outline.set_linewidth(0.4)
    cbar.outline.set_edgecolor('black')
    cbar.ax.tick_params(width=0.4)  # , labelsize=4)

def boxplot(df, label=None, figsize=None, dpi=100):
    """
    Create a boxplot from the variables in df.
    The box shows the quartiles of the dataset while the whiskers extend
    to show the rest of the distribution, except for points that are
    determined to be “outliers” using a method that is a function of
    the inter-quartile range.

    Parameters
    ----------
    df : pandas.DataFrame
        DataFrame containing 'lat', 'lon' and (multiple) 'var' Series.
    title : str, optional (default: None)
        Title of the plot. If None, no title is added.
    label : str, optional
        Label of the y axis, describing the metric. If None, a label is autogenerated from metadata.
        The default is None.
    figsize : tuple, optional
        Figure size in inches. The default is globals.map_figsize.
    dpi : int, optional
        Resolution for raster graphic output. The default is globals.dpi.
    title_pad : float, optional
        pad the title by title_pad pt. The default is globals.title_pad.

    Returns
    -------
    fig : TYPE
        DESCRIPTION.
    ax : TYPE
        DESCRIPTION.

    """
    df = df.copy()
    # === plot ===
    sns.set_style("whitegrid")  # TODO: Bug. does not work for the first plot (test_boxplot_ISMN_default()) for some strange reason!!!
    fig, ax = plt.subplots(figsize=figsize, dpi=dpi)
    ax = sns.boxplot(data=df, ax=ax, width=0.15, showfliers=False, color='white')
    sns.despine()  # remove ugly spines (=border around plot) right and top.

    if label is not None:
        ax.set_ylabel(label, weight='normal')  # TODO: Bug: If a circumflex ('^') is in the string, it becomes bold.)

    return fig, ax


def mapplot(df, var, meta, plot_extent=None, colormap=None, projection=None,
            add_cbar=True, figsize=globals.map_figsize, dpi=globals.dpi,
             **style_kwargs):
    """
    Create an overview map from df using df[var] as color.
    Plots a scatterplot for ISMN and a image plot for other input data.

    Parameters
    ----------
    df : pandas.DataFrame
        DataFrame with lat and lon in the multiindex and var as a column
    var : str
        variable to be plotted.
    meta : dict
        dictionary of metadata. See interface.get_meta().
    label : str, optional
        Label of the colorbar. If None, a label is autogenerated from metadata.
        The default is None.
    plot_extent : tuple
        (x_min, x_max, y_min, y_max) in Data coordinates. The default is None.
    colormap : Colormap, optional
        colormap to be used.
        If None, defaults to globals._colormaps.
    figsize : tuple, optional
        Figure size in inches. The default is globals.map_figsize.
    dpi : int, optional
        Resolution for raster graphic output. The default is globals.dpi.
    projection : cartopy.crs, optional
        Projection to be used. If none, defaults to globals.map_projection.
        The default is None.
    add_title : bool, optional
        The default is True.
    add_cbar : bool, optional
        Add a colorbar. The default is True.
    **style_kwargs :
        Keyword arguments for plotter.style_map().

    Returns
    -------
    fig : TYPE
        DESCRIPTION.
    ax : TYPE
        DESCRIPTION.
    """
    # === value range ===
    if isinstance(meta['metric'], list):
        meta['metric'] = meta['metric'][0]
    v_min, v_max = get_value_range(df[var], str(meta['metric']))

    # === init plot ===
    fig, ax, cax = init_plot(figsize, dpi, add_cbar, projection)

    if not colormap:
        #colormap = globals._colormaps[meta['metric']]
        cmap = globals._colormaps[meta['metric']]
    else:
        cmap = colormap
    #cmap = plt.cm.get_cmap(colormap)

    # === scatter or mapplot ===
    if meta['ref'] in globals.scattered_datasets:  # === scatterplot ===
        # === coordiniate range ===
        if not plot_extent:
            plot_extent = get_plot_extent(df)

        # === marker size ===
        markersize = globals.markersize ** 2  # in points**2

        # === plot ===
        lat, lon = globals.index_names
        im = ax.scatter(df.index.get_level_values(lon), df.index.get_level_values(lat),
                        c=df[var], cmap=cmap, s=markersize, vmin=v_min, vmax=v_max, edgecolors='black',
                        linewidths=0.1, zorder=2, transform=globals.data_crs)
    else:  # === mapplot ===
        # === coordiniate range ===
        if not plot_extent:
            plot_extent = get_plot_extent(df, grid=True)

        # === prepare data ===
        zz, zz_extent = geotraj_to_geo2d(df, var)

        # === plot ===
        im = ax.imshow(zz, cmap=cmap, vmin=v_min, vmax=v_max,
                       interpolation='nearest', origin='lower',
                       extent=zz_extent,
                       transform=globals.data_crs, zorder=2)

    # === add colorbar ===
    if add_cbar:
        _make_cbar(fig, im, cax, meta)

    style_map(ax, plot_extent, **style_kwargs)

    # === layout ===
    fig.canvas.draw()  # very slow. necessary bcs of a bug in cartopy: https://github.com/SciTools/cartopy/issues/1207
    #plt.tight_layout()  # pad=1)  # pad=0.5,h_pad=1,w_pad=1,rect=(0, 0, 1, 1))
    return fig, ax

class QA4SM_MetaImg_Plotter(QA4SM_MetaImg):
    def __init__(self, filepath, extent=None, index_names=globals.index_names):
        super(QA4SM_MetaImg_Plotter, self).__init__(filepath, extent, index_names)

    @staticmethod
    def _get_dir_name_type(out_name, out_type='png', out_dir=None):
        """
        Standardized behaviour for filenames.

        Parameters
        ----------

        out_name : str
            output filename.
            if it contains an extension (e.g. 'MyName.png'), the extension is added to out_ext.
        out_type : str or iterable, optional (default: None)
            contains file extensions to be plotted.
            if None, '.png' is used. If '.' is missing, it is added.
        out_dir : str, optional (default: None)
            path to the output directory.
            if None, uses the current working directory.

        Returns
        -------
        out_dir : str
        out_name : str
        out_ext : set
            file extensions

        """
        # directory
        if not out_dir:
            out_dir = ''
        out_dir = os.path.abspath(out_dir)
        # file name
        (out_name, ext) = os.path.splitext(out_name)  # remove extension
        # file type
        if not out_type:
            if ext:
                out_type = ext
            else:
                out_type = '.png'
        # convert to a set
        if isinstance(out_type, str):
            out_type = {out_type}
        else:  # some iterable
            out_type = set(out_type)
        if ext:
            out_type.add(ext)
        out_type = {ext if ext[0] == "." else "." + ext for ext in out_type}  # make sure all entries start with a '.'
        return out_dir, out_name, out_type

    def _ds_pretty_names(self, meta):
        if isinstance(meta['metric'], list):
            metric = meta['metric'][0]
        else:
            metric = meta['metric']

        ref_pretty = meta['ref_pretty_name']
        ref_version_pretty = meta['ref_version_pretty_name']

        ds_pretty = []
        ds_version_pretty = []
        if metric in globals.metric_groups[0]:
            _, ds_short_names = self.get_short_names()
            n_ds = len(list(ds_short_names))
        elif metric in globals.metric_groups[2]:
            n_ds = 1
        else:
            n_ds = 2

        for i in range(1, n_ds+1):
            ds_pretty.append(meta['ds{}_pretty_name'.format(i)])
            ds_version_pretty.append(meta['ds{}_version_pretty_name'.format(i)])

        return (ref_pretty, ref_version_pretty), (ds_pretty, ds_version_pretty)


    def _title(self, varmeta=None, max_len=100):
        ref_parts = []
        ds_parts = []
        for var, meta in varmeta.items():
            (ref_pretty, ref_version_pretty), (ds_pretty, ds_version_pretty) = \
                self._ds_pretty_names(meta)
            ref_parts.append([ref_pretty, ref_version_pretty])
            for d, v in zip(ds_pretty, ds_version_pretty):
                ds_parts.append(('{0} ({1})'.format(d, v)))

        # make sure all vars have the same reference data set
        assert all([ref_part == ref_parts[0] for ref_part in ref_parts])
        title_ref_part = 'Comparing {0} ({1}) to '.format(ref_parts[0][0], ref_parts[0][1])

        title = ''
        parts = [title_ref_part] + ds_parts
        for i, part in enumerate(parts):
            if i > 0 and i < len(parts)-1 :
                part = part + ' and '
            if len(title.split('\n')[-1]) + len(part) > max_len:
                part += '\n'
            title = title + part

        return title


    def boxplot(self, metric, out_dir=None, out_name=None, out_type=None):
        """
        Creates a boxplot, displaying the variables corresponding to given metric.
        Saves a figure and returns Matplotlib fig and ax objects for further processing.

        Parameters
        ----------
        metric : str
            metric that is collected from the file for all datasets and combined
            into one plot.
        out_dir : str, optional (default: None)
            Path to output generated plot.
            If None, defaults to the current working directory.
            The default is None.
        out_name : [ None | str ], optional
            Name of output file.
            If None, defaults to a name that is generated based on the variables.
            The default is None.
        out_type : [ str | list | None ], optional
            The file type, e.g. 'png', 'pdf', 'svg', 'tiff'...
            If list, a plot is saved for each type.
            If None, no file is saved.
            The default is png.
        **plot_kwargs : dict, optional
            Additional keyword arguments that are passed to dfplot.boxplot.

        Returns
        -------
        fig : matplotlib.figure.Figure
            Figure containing the axes for further processing.
        ax : matplotlib.axes.Axes or list of Axes objects
            Axes or list of axes containing the plot.
        """
        fnames = list()  # list to store all filenames.
        # === load data and metadata ===
        df, varmeta = self.load_metric_and_meta(metric)
        vars = list(varmeta.keys())

        ref_short_name, _ = self.get_short_names()

        # === rename columns = label of boxes ===
        for var in vars:
            if metric in globals.metric_groups[0]:
                ds_part = 'All datasets'
            else:
                ds = 2 if metric in globals.metric_groups[2] else 3
                ds_parts = []
                for i in range(1, ds):
                    ds_parts.append('{0}\n({1})'.format(varmeta[var]['ds{}_pretty_name'.format(i)],
                                                        varmeta[var]['ds{}_version_pretty_name'.format(i)]))
                ds_part = '\n'.join(ds_parts)
            if globals.boxplot_printnumbers:
                m_part = 'median: {0:.3g}\nstd. dev.: {1:.3g}\nN obs.: {2:d}'.format(
                    df[var].median(),
                    df[var].std(),
                    df[var].count())
                new_name = '{}\n{}'.format(ds_part, m_part)
            else:
                new_name = ds_part
            df = df.rename(columns={var: new_name})

        # === create title ===
        max_title_len = globals.boxplot_title_len * len(df.columns)
        title = self._title(varmeta, max_title_len)

        # === create label ===
        label = (globals._metric_name[metric] +
                 globals._metric_description[metric].format(
                     globals._metric_units[ref_short_name]))

        figsize = [globals.boxplot_width * (1 + len(df.columns)),
                   globals.boxplot_height]

        # === plot data ===
        fig, ax = boxplot(df=df, label=label, figsize=figsize, dpi=globals.dpi)

        # === set limits ===
        ax.set_ylim(get_value_range(df, metric))

        # === add title ===
        ax.set_title(title, pad=globals.title_pad)

        # === add watermark ===
        if globals.watermark_pos not in [None, False]:
            make_watermark(fig, globals.watermark_pos)
        # === save ===
        if not out_name:
            out_name = 'boxplot_{}'.format(metric)

        if out_dir is None:
            return fig, ax
        else:
            out_dir, out_name, out_type = self._get_dir_name_type(
                out_name, out_type, out_dir)
            if not os.path.exists(out_dir):
                os.makedirs(out_dir)
            for ending in out_type:
                fname = os.path.join(out_dir, out_name+ending)
                plt.savefig(fname, dpi='figure', bbox_inches='tight')
                fnames.append(fname)
            plt.close()
            return fnames

    def mapplot(self, var, out_dir=None, out_name=None, out_type=None,
                **plot_kwargs):
        """
        Plots data to a map, using the data as color. Plots a scatterplot for
        ISMN and a image plot for other input data.

        Parameters
        ----------
        filepath : str
            Path to the *.nc file to be processed.
        var : str
            variable to be plotted.
        extent : list
            [x_min,x_max,y_min,y_max] to create a subset of the data
        out_dir : [ None | str ], optional
            Path to output generated plot.
            If None, defaults to the current working directory.
            The default is None.
        out_name : [ None | str ], optional
            Name of output file.
            If None, defaults to a name that is generated based on the variables.
            The default is None.
        out_type : [ str | list | None ], optional
            The file type, e.g. 'png', 'pdf', 'svg', 'tiff'...
            If list, a plot is saved for each type.
            If None, no file is saved.
            The default is png.
        **plot_kwargs : dict, optional
            Additional keyword arguments that are passed to dfplot.

        Returns
        -------
        fig : matplotlib.figure.Figure
            Figure containing the axes for further processing.
        ax : matplotlib.axes.Axes or list of Axes objects
            Axes or list of axes containing the plot.

        """
        fnames = list()  # list to store all filenames.

        df = self._ds2df([var])
        varmeta = self.get_var_meta([var])

        meta = varmeta[var]
        # === plot data ===
        fig, ax = mapplot(df=df, var=var,
                          plot_extent=self.extent, meta=meta, **plot_kwargs)
        # === add title ===
        ax.set_title(self._title(varmeta), pad=globals.title_pad)

        # === add watermark ===
        if globals.watermark_pos not in [None, False]:
            make_watermark(fig, globals.watermark_pos)
        plt.tight_layout()
        # === save ===
        if not out_name:
            out_name = 'overview_{}'.format(var)

        if out_dir is None:
            return fig, ax
        else:
            out_dir, out_name, out_type = \
                self._get_dir_name_type(out_name, out_type, out_dir)
            if not os.path.exists(out_dir):
                os.makedirs(out_dir)
            for ending in out_type:
                fname = os.path.join(out_dir, out_name+ending)
                plt.savefig(fname, dpi='figure', bbox_inches='tight')
                fnames.append(fname)
            plt.close()
        return fnames

def testcase_normal():
    files = [r"H:\code\qa4sm-reader\tests\test_data\3-ERA5_LAND.swvl1_with_1-C3S.sm_with_2-SMOS.Soil_Moisture.nc",
             r"H:\code\qa4sm-reader\tests\test_data\3-GLDAS.SoilMoi0_10cm_inst_with_1-C3S.sm_with_2-ESA_CCI_SM_combined.sm.nc",
             r"H:\code\qa4sm-reader\tests\test_data\2-ISMN.soil moisture_with_1-C3S.sm.nc",
             r"H:\code\qa4sm-reader\tests\test_data\4-ERA5.swvl1_with_1-C3S.sm_with_2-ASCAT.sm_with_3-SMOS.Soil_Moisture.nc",
             r"H:\code\qa4sm-reader\tests\test_data\6-ISMN.soil moisture_with_1-C3S.sm_with_2-C3S.sm_with_3-SMOS.Soil_Moisture_with_4-SMAP.soil_moisture_with_5-ASCAT.sm.nc"]
    for i, afile in enumerate(files):
        if i < 4: continue
        plotter = QA4SM_MetaImg_Plotter(afile)
        out_dir = r"C:\Temp\qa4smreader_plots\{}".format(i)
        metrics = plotter.metrics_in_file(group=False)

        for metric in metrics:
            plotter.boxplot(metric, out_dir=out_dir)
            vars = plotter._met2vars(metric)
            print(vars)
            for var in vars:
                plotter.mapplot(var, out_dir=out_dir)

def testcase_tc():
    #afile=r"H:\code\qa4sm-reader\tests\test_data\3-ERA5.swvl1_with_1-SMOS.Soil_Moisture_with_2-SMOS.Soil_Moisture.nc"
    afile = r"H:\code\qa4sm-reader\tests\test_data\3-GLDAS.SoilMoi0_10cm_inst_with_1-C3S.sm_with_2-ESA_CCI_SM_combined.sm.nc"
    plotter = QA4SM_MetaImg_Plotter(afile)
    out_dir = r"C:\Temp\qa4smreader_plots"
    metrics = plotter.metrics_in_file(group=False)

    for metric in metrics:
        print(metric)
        vars = plotter._met2vars(metric)
        for metric in metrics:
            plotter.boxplot(metric)

        for var in vars:
            plotter.mapplot(var, out_dir=out_dir)

if __name__ == '__main__':
    testcase_normal()


